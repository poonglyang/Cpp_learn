/*
[바인딩]
	함수가 호출될 때 함수의 주소를 연결


[정적 바인딩]
	컴파일 타임에 함수 호출이 어떤 함수를 연결될지 결장하는 방식
	컴파일 타임에 결정되기 때문에 실행 속도 빠르다.
	컴파일 타임에 모든것이 결정되기에 런타임 성능에 영향을 미치지 않는다.

[동적 바인딩]
	가상함수와 가상함수 테이블과 관련이 있다.
	런타임에 함수 호출이 어떤 함수로 연결될지 결정하는 방식
		-> 바인딩을 실행시간에 결정하도록 미뤄놨다가 호출
	오버라이딩된 가상함수를 동적으로 찾아 호출
	실행중에 결정이 되기 때문에 상대적으로 오버헤드가 발생할 수 있음
	어떤 포인터에 의해 접근되었는지에 상관 없이 참조된 인스턴스의 실제 클래스 형에 따라 재정의된 함수 호출이 가능하다

[VTable] - 자세한 것은 추가적으로 보자
	가상함수 테이블은 각 클래스가 가지고 있는 가상함수에 대한 포인터를 저장하는 테이블
	각 클래스는 자신만의 가상함수 테이블을 가지고 있고 가상함수 테이블은 해당 클래스의 가상함수들이 메모리에 어느 위치에 있는지 가리킨다.
	객체가 생성될 때 해당 객체는 그 클래스의 가상함수 테이블을 가리키는 포인터를 가지며 런타임에 적절한 함수가 호출된다.
*/


#include <iostream>

class A {
public :
	A() = default;

	void Print(int i) {
		std::cout << "int형 매개변수 받아 출력 : " << i << std::endl;
	}

	void Print(double d) {
		std::cout << "double형 매개변수 받아 출력 : " << d << std::endl;
	}
};

class Parent {
public:

	virtual void Show() const {
		std::cout << "부모" << std::endl;
	}
};

class Child : public Parent {
	void Show() const override {
		std::cout << "자식" << std::endl;
	}
};

int main() {
	A* a = new A();
	a->Print(10.5);				// 매개변수에 따라 함수 호출이 지정되는 정적 바인딩
	a->Print(10);				// 매개변수에 따라 함수 호출이 지정되는 정적 바인딩

	Parent* p = new Child();	// 부모 클래스 포인터가 자식을 
	p->Show();					// 동적 바인딩
}	